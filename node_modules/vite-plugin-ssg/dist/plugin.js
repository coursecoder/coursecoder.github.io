// src/gen-static.ts
import path7 from "path";
import fs6 from "fs";

// src/page-discovery.ts
import path from "path";
import fs from "fs";
function extractSsgOptionsFromFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    const ssgOptionsMatch = content.match(
      /export\s+const\s+ssgOptions\s*(?::\s*\w+)?\s*=\s*\{([\s\S]*?)\n\};/
    );
    if (!ssgOptionsMatch) {
      return null;
    }
    const optionsContent = ssgOptionsMatch[1];
    const slugMatch = optionsContent.match(/slug\s*:\s*["'`]([^"'`]+)["'`]/);
    if (!slugMatch) {
      return null;
    }
    const slug = slugMatch[1];
    const routeUrlMatch = optionsContent.match(/routeUrl\s*:\s*["'`]([^"'`]+)["'`]/);
    const routeUrl = routeUrlMatch ? routeUrlMatch[1] : "/";
    const hasHead = /Head\s*:\s*(?:\(\)|[^,}])/.test(optionsContent) || /Head\s*\(\s*\)/.test(optionsContent);
    const hasContext = /context\s*:\s*(?:async\s*)?\(/.test(optionsContent) || /context\s*:\s*\w+/.test(optionsContent);
    return {
      slug,
      routeUrl,
      hasHead,
      hasContext
    };
  } catch (error) {
    console.warn(`[SSG] Failed to parse ${filePath}:`, error);
    return null;
  }
}
async function discoverPages(input, _config) {
  const absoluteInput = path.isAbsolute(input) ? input : path.join(process.cwd(), input);
  const stats = fs.statSync(absoluteInput);
  const pages = [];
  if (stats.isFile()) {
    const ssgOptions = extractSsgOptionsFromFile(absoluteInput);
    if (!ssgOptions) {
      throw new Error(
        `File ${absoluteInput} does not export 'ssgOptions'. Single file input requires ssgOptions export.`
      );
    }
    pages.push({
      componentPath: absoluteInput,
      slug: ssgOptions.slug,
      routeUrl: ssgOptions.routeUrl,
      hasHead: ssgOptions.hasHead,
      hasContext: ssgOptions.hasContext
    });
  } else if (stats.isDirectory()) {
    const files = fs.readdirSync(absoluteInput).filter((f) => f.endsWith(".tsx") || f.endsWith(".jsx")).map((f) => path.join(absoluteInput, f));
    console.log(`[SSG] Scanning ${files.length} files in ${absoluteInput}...`);
    for (const filePath of files) {
      const ssgOptions = extractSsgOptionsFromFile(filePath);
      if (ssgOptions) {
        pages.push({
          componentPath: filePath,
          slug: ssgOptions.slug,
          routeUrl: ssgOptions.routeUrl,
          hasHead: ssgOptions.hasHead,
          hasContext: ssgOptions.hasContext
        });
        console.log(
          `[SSG] Found page: ${path.basename(filePath)} -> ${ssgOptions.slug}`
        );
      } else {
        console.warn(
          `[SSG] Skipping ${path.basename(filePath)} (no ssgOptions export)`
        );
      }
    }
  } else {
    throw new Error(`Input ${absoluteInput} is neither a file nor a directory`);
  }
  return pages;
}

// src/island-scanner.ts
import fs2 from "fs";
import path2 from "path";
function hasIslandDirective(filePath) {
  try {
    const content = fs2.readFileSync(filePath, "utf-8");
    const firstLine = content.split("\n")[0].trim();
    return /^['"]use island['"];?$/.test(firstLine);
  } catch {
    return false;
  }
}
function resolveComponentPath(componentPath, srcDir) {
  const basePath = path2.join(srcDir, componentPath);
  const extensions = [".tsx", ".ts", ".jsx", ".js"];
  for (const ext of extensions) {
    const fullPath = basePath + ext;
    if (fs2.existsSync(fullPath) && fs2.statSync(fullPath).isFile()) {
      return fullPath;
    }
  }
  for (const ext of extensions) {
    const indexPath = path2.join(basePath, `index${ext}`);
    if (fs2.existsSync(indexPath)) {
      return indexPath;
    }
  }
  return null;
}
function getComponentName(componentPath) {
  return componentPath.split("/").pop() || componentPath;
}
function extractIslandUsages(filePath) {
  try {
    const content = fs2.readFileSync(filePath, "utf-8");
    const usages = [];
    const islandRegex = /<Island\s+[^>]*component=["'{]([^"'}]+)["'}]/g;
    let match;
    while ((match = islandRegex.exec(content)) !== null) {
      usages.push(match[1]);
    }
    return usages;
  } catch {
    return [];
  }
}
function extractImports(filePath) {
  try {
    const content = fs2.readFileSync(filePath, "utf-8");
    const imports = [];
    const importRegex = /import\s+(?:[\w\s{},*]+\s+from\s+)?['"]([^'"]+)['"]/g;
    let match;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
    }
    return imports;
  } catch {
    return [];
  }
}
function resolveImportPath(importPath, fromFile, srcDir) {
  if (!importPath.startsWith(".") && !importPath.startsWith("/")) {
    return null;
  }
  const fromDir = path2.dirname(fromFile);
  let resolved;
  if (importPath.startsWith(".")) {
    resolved = path2.resolve(fromDir, importPath);
  } else {
    resolved = path2.resolve(srcDir, importPath);
  }
  const extensions = ["", ".tsx", ".ts", ".jsx", ".js"];
  for (const ext of extensions) {
    const fullPath = resolved + ext;
    if (fs2.existsSync(fullPath) && fs2.statSync(fullPath).isFile()) {
      return fullPath;
    }
  }
  for (const ext of [".tsx", ".ts", ".jsx", ".js"]) {
    const indexPath = path2.join(resolved, `index${ext}`);
    if (fs2.existsSync(indexPath)) {
      return indexPath;
    }
  }
  return null;
}
function scanForIslands(entryFile, srcDir) {
  const islands = [];
  const foundComponentPaths = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const queue = [entryFile];
  while (queue.length > 0) {
    const currentFile = queue.shift();
    if (visited.has(currentFile)) continue;
    visited.add(currentFile);
    const islandUsages = extractIslandUsages(currentFile);
    for (const componentPath of islandUsages) {
      foundComponentPaths.add(componentPath);
    }
    const imports = extractImports(currentFile);
    for (const imp of imports) {
      const resolvedPath = resolveImportPath(imp, currentFile, srcDir);
      if (resolvedPath && !visited.has(resolvedPath)) {
        queue.push(resolvedPath);
      }
    }
  }
  for (const componentPath of foundComponentPaths) {
    const resolvedPath = resolveComponentPath(componentPath, srcDir);
    if (!resolvedPath) {
      console.warn(`[Island Scanner] Could not resolve component: ${componentPath}`);
      continue;
    }
    if (!hasIslandDirective(resolvedPath)) {
      console.warn(`[Island Scanner] Component missing 'use island' directive: ${componentPath}`);
      continue;
    }
    const name = getComponentName(componentPath);
    if (!islands.find((i) => i.importPath === componentPath)) {
      islands.push({
        name,
        filePath: resolvedPath,
        importPath: componentPath
      });
    }
  }
  return islands;
}
function generateHydrationScript(islands) {
  if (islands.length === 0) {
    return `// No islands detected - nothing to hydrate
export {};
`;
  }
  const imports = islands.map(
    (island) => `import ${island.name} from '${island.filePath}';`
  ).join("\n");
  const registry = islands.map(
    (island) => `  ${island.name},`
  ).join("\n");
  return `/**
 * Auto-generated Island Hydration Script
 *
 * This file is automatically generated by the static site generator.
 * Do not edit manually.
 */

import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import { BrowserRouter, MemoryRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Auto-detected island components
${imports}

// Island component registry
const islandComponents: Record<string, React.ComponentType<any>> = {
${registry}
};

// Create a single QueryClient for all islands
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      retry: false,
    },
  },
});

// Get the SSR route from the embedded script (for hydration consistency)
declare global {
  interface Window {
    __SSR_ROUTE__?: string;
  }
}

function hydrateIslands() {
  const islands = document.querySelectorAll('[data-island]');
  // Use MemoryRouter with SSR route for initial hydration to match server state
  const ssrRoute = window.__SSR_ROUTE__ || '/';

  islands.forEach((island) => {
    const name = island.getAttribute('data-island');
    const propsJson = island.getAttribute('data-island-props') || '{}';

    if (!name) return;

    const Component = islandComponents[name];
    if (!Component) {
      console.warn(\`Unknown island component: \${name}\`);
      return;
    }

    try {
      const props = JSON.parse(propsJson);

      // Use MemoryRouter with the SSR route to match server-rendered state
      // This ensures hydration doesn't fail due to URL differences
      const element = (
        <QueryClientProvider client={queryClient}>
          <MemoryRouter initialEntries={[ssrRoute]}>
            <Component {...props} />
          </MemoryRouter>
        </QueryClientProvider>
      );

      hydrateRoot(island, element);
      console.log(\`Hydrated island: \${name}\`);
    } catch (error) {
      console.error(\`Failed to hydrate island \${name}:\`, error);
    }
  });
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrateIslands);
} else {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(hydrateIslands);
  } else {
    setTimeout(hydrateIslands, 1);
  }
}
`;
}

// src/ssr-renderer.ts
import path3 from "path";
import { fileURLToPath } from "url";
import { createRequire } from "module";

// src/config.ts
var DEFAULT_CONFIG = {
  outDir: "dist/static",
  baseUrl: "/static",
  srcDir: "src",
  vite: {
    plugins: []
  },
  images: {
    enabled: true,
    formats: ["webp"],
    quality: 80,
    generateSrcset: true,
    srcsetMultipliers: [1, 2],
    lcpImageCount: 4
  },
  css: {
    minify: "lightningcss",
    globalCssPath: "src/index.css"
  },
  js: {
    minify: "terser",
    target: "es2020",
    terserOptions: {
      dropConsole: true,
      dropDebugger: true,
      passes: 2
    }
  },
  html: {
    headTags: "",
    bodyTags: "",
    lang: "en"
  },
  logLevel: "info"
};
function deepMerge(target, source) {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    const sourceValue = source[key];
    const targetValue = result[key];
    if (sourceValue === void 0) {
      continue;
    }
    if (typeof sourceValue === "object" && sourceValue !== null && !Array.isArray(sourceValue) && typeof targetValue === "object" && targetValue !== null && !Array.isArray(targetValue)) {
      result[key] = {
        ...targetValue,
        ...sourceValue
      };
    } else {
      result[key] = sourceValue;
    }
  }
  return result;
}
function resolveConfig(userConfig = {}) {
  return deepMerge(DEFAULT_CONFIG, userConfig);
}
function toViteLogLevel(level) {
  if (level === "debug") {
    return "info";
  }
  return level;
}

// src/ssr-renderer.ts
var __dirname = path3.dirname(fileURLToPath(import.meta.url));
var require2 = createRequire(path3.join(process.cwd(), "package.json"));
var { createServer } = require2("vite");
var reactPlugin = require2("@vitejs/plugin-react").default;
var tailwindcss = require2("@tailwindcss/vite").default;
async function renderPage(options) {
  const { componentPath, routeUrl, islands, renderHead: shouldRenderHead, config } = options;
  const serverEntryPath = path3.join(__dirname, "..", "src", "server-entry.tsx");
  const vite = await createServer({
    configFile: false,
    // Don't load vite.config.ts
    root: process.cwd(),
    // Use project's root to resolve node_modules
    plugins: [reactPlugin(), tailwindcss(), ...config.vite.plugins],
    appType: "custom",
    logLevel: toViteLogLevel(config.logLevel),
    ssr: {
      external: ["sharp", "fsevents"]
    }
  });
  try {
    const { render, renderHead } = await vite.ssrLoadModule(serverEntryPath);
    const bodyHtml = await render(componentPath, routeUrl, islands);
    let headHtml = "";
    if (shouldRenderHead) {
      headHtml = await renderHead(componentPath);
    }
    return { bodyHtml, headHtml };
  } finally {
    await vite.close();
  }
}

// src/image-optimizer.ts
import fs3 from "fs";
import path4 from "path";
import crypto from "crypto";
function decodeHtmlEntities(url) {
  return url.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
function extractImages(html) {
  const images = [];
  const imgRegex = /<img\s+([^>]*?)>/gi;
  let match;
  while ((match = imgRegex.exec(html)) !== null) {
    const attrs = match[1];
    const srcMatch = attrs.match(/src=["']([^"']+)["']/i);
    if (!srcMatch) continue;
    const url = decodeHtmlEntities(srcMatch[1]);
    if (url.startsWith("data:") || url.endsWith(".svg")) continue;
    const widthMatch = attrs.match(/width=["']?(\d+)["']?/i);
    const heightMatch = attrs.match(/height=["']?(\d+)["']?/i);
    const width = widthMatch ? parseInt(widthMatch[1], 10) : null;
    const height = heightMatch ? parseInt(heightMatch[1], 10) : null;
    const isExternal = url.startsWith("http://") || url.startsWith("https://");
    images.push({
      url,
      width,
      height,
      isExternal,
      element: match[0],
      originalEncodedUrl: srcMatch[1]
      // Keep original encoded URL for replacement
    });
  }
  return images;
}
function generateFilename(url, width, format) {
  const hash = crypto.createHash("md5").update(url).digest("hex").slice(0, 8);
  const urlPath = new URL(url).pathname;
  const baseName = path4.basename(urlPath, path4.extname(urlPath)).replace(/[^a-zA-Z0-9-_]/g, "_");
  const sizeSuffix = width ? `_${width}w` : "";
  return `${baseName}_${hash}${sizeSuffix}.${format}`;
}
async function downloadImage(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download ${url}: ${response.status}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer);
}
async function getSharp() {
  try {
    const sharp = await import("sharp");
    return sharp.default;
  } catch {
    return null;
  }
}
async function optimizeImage(imageBuffer, targetWidth, targetHeight, format, quality, sharp) {
  let pipeline = sharp(imageBuffer);
  const metadata = await pipeline.metadata();
  const origWidth = metadata.width || 800;
  const origHeight = metadata.height || 600;
  let finalWidth = targetWidth || origWidth;
  let finalHeight = targetHeight || origHeight;
  if (targetWidth && !targetHeight) {
    finalHeight = Math.round(origHeight * (targetWidth / origWidth));
  } else if (!targetWidth && targetHeight) {
    finalWidth = Math.round(origWidth * (targetHeight / origHeight));
  }
  if (finalWidth > origWidth) {
    finalWidth = origWidth;
    finalHeight = origHeight;
  }
  if (finalWidth !== origWidth || finalHeight !== origHeight) {
    pipeline = pipeline.resize(finalWidth, finalHeight, {
      fit: "cover",
      withoutEnlargement: true
    });
  }
  let outputFormat = format === "original" ? metadata.format || "jpeg" : format;
  let buffer;
  if (format === "webp") {
    buffer = await pipeline.webp({ quality }).toBuffer();
    outputFormat = "webp";
  } else if (format === "avif") {
    buffer = await pipeline.avif({ quality }).toBuffer();
    outputFormat = "avif";
  } else {
    if (metadata.format === "jpeg" || metadata.format === "jpg") {
      buffer = await pipeline.jpeg({ quality }).toBuffer();
    } else if (metadata.format === "png") {
      buffer = await pipeline.png({ compressionLevel: 9 }).toBuffer();
    } else {
      buffer = await pipeline.toBuffer();
    }
  }
  return {
    buffer,
    width: finalWidth,
    height: finalHeight,
    format: outputFormat
  };
}
async function optimizeImages(html, options) {
  const {
    outputDir,
    baseUrl,
    formats = ["webp"],
    quality = 80,
    generateSrcset = false,
    srcsetMultipliers = [1, 2],
    concurrency = 5
  } = options;
  const sharp = await getSharp();
  if (!sharp) {
    console.warn("[Image Optimizer] sharp not installed. Run: npm install sharp");
    console.warn("[Image Optimizer] Skipping image optimization");
    return { html, images: [] };
  }
  const imagesDir = path4.join(outputDir, "images");
  fs3.mkdirSync(imagesDir, { recursive: true });
  const images = extractImages(html);
  console.log(`[Image Optimizer] Found ${images.length} images to process`);
  if (images.length === 0) {
    return { html, images: [] };
  }
  const optimizedImages = [];
  const replacements = /* @__PURE__ */ new Map();
  const uniqueUrls = [...new Set(images.filter((img) => img.isExternal).map((img) => img.url))];
  const downloadCache = /* @__PURE__ */ new Map();
  console.log(`[Image Optimizer] Downloading ${uniqueUrls.length} unique external images...`);
  for (let i = 0; i < uniqueUrls.length; i += concurrency) {
    const batch = uniqueUrls.slice(i, i + concurrency);
    const results = await Promise.allSettled(
      batch.map(async (url) => {
        const buffer = await downloadImage(url);
        return { url, buffer };
      })
    );
    for (const result of results) {
      if (result.status === "fulfilled") {
        downloadCache.set(result.value.url, result.value.buffer);
      } else {
        console.warn(`[Image Optimizer] Failed to download: ${result.reason}`);
      }
    }
  }
  for (const img of images) {
    if (!img.isExternal) {
      continue;
    }
    const imageBuffer = downloadCache.get(img.url);
    if (!imageBuffer) {
      console.warn(`[Image Optimizer] No buffer for ${img.url}, skipping`);
      continue;
    }
    try {
      const primaryFormat = formats[0] || "webp";
      const optimized = await optimizeImage(
        imageBuffer,
        img.width,
        img.height,
        primaryFormat,
        quality,
        sharp
      );
      const filename = generateFilename(img.url, img.width, optimized.format);
      const localPath = path4.join(imagesDir, filename);
      const localUrl = `${baseUrl}/images/${filename}`;
      fs3.writeFileSync(localPath, optimized.buffer);
      let srcset;
      if (generateSrcset && img.width) {
        const srcsetParts = [];
        for (const multiplier of srcsetMultipliers) {
          const srcsetWidth = Math.round(img.width * multiplier);
          const srcsetOptimized = await optimizeImage(
            imageBuffer,
            srcsetWidth,
            null,
            primaryFormat,
            quality,
            sharp
          );
          const srcsetFilename = generateFilename(img.url, srcsetWidth, srcsetOptimized.format);
          const srcsetPath = path4.join(imagesDir, srcsetFilename);
          const srcsetUrl = `${baseUrl}/images/${srcsetFilename}`;
          if (srcsetFilename !== filename) {
            fs3.writeFileSync(srcsetPath, srcsetOptimized.buffer);
          }
          srcsetParts.push(`${srcsetUrl} ${multiplier}x`);
        }
        srcset = srcsetParts.join(", ");
      }
      optimizedImages.push({
        originalUrl: img.url,
        localPath,
        localUrl,
        width: optimized.width,
        height: optimized.height,
        format: optimized.format,
        size: optimized.buffer.length,
        srcset
      });
      let newElement = img.element.replace(/src=["'][^"']+["']/, `src="${localUrl}"`).replace(/width=["']?\d+["']?/, `width="${optimized.width}"`).replace(/height=["']?\d+["']?/, `height="${optimized.height}"`);
      if (srcset && !newElement.includes("srcset=")) {
        newElement = newElement.replace(/<img\s/, `<img srcset="${srcset}" `);
      }
      if (!newElement.includes("loading=") && optimizedImages.length > 4) {
        newElement = newElement.replace(/<img\s/, '<img loading="lazy" ');
      }
      replacements.set(img.element, newElement);
    } catch (error) {
      console.warn(`[Image Optimizer] Failed to optimize ${img.url}:`, error);
    }
  }
  let optimizedHtml = html;
  for (const [original, replacement] of replacements) {
    optimizedHtml = optimizedHtml.split(original).join(replacement);
  }
  const totalOriginal = optimizedImages.reduce((sum, img) => {
    const origBuffer = downloadCache.get(img.originalUrl);
    return sum + (origBuffer?.length || 0);
  }, 0);
  const totalOptimized = optimizedImages.reduce((sum, img) => sum + img.size, 0);
  const savings = totalOriginal - totalOptimized;
  const savingsPercent = totalOriginal > 0 ? (savings / totalOriginal * 100).toFixed(1) : 0;
  console.log(`[Image Optimizer] Optimized ${optimizedImages.length} images`);
  console.log(`[Image Optimizer] Size: ${(totalOriginal / 1024).toFixed(1)}KB \u2192 ${(totalOptimized / 1024).toFixed(1)}KB (${savingsPercent}% savings)`);
  return { html: optimizedHtml, images: optimizedImages };
}
function generateImagePreloads(images, maxImages = 4) {
  return images.slice(0, maxImages).map((img) => {
    const type = img.format === "webp" ? "image/webp" : img.format === "avif" ? "image/avif" : "image/jpeg";
    return `<link rel="preload" as="image" href="${img.localUrl}" type="${type}" fetchpriority="high">`;
  }).join("\n    ");
}

// src/css-builder.ts
import path5 from "path";
import fs4 from "fs";
import { createRequire as createRequire2 } from "module";
var require3 = createRequire2(path5.join(process.cwd(), "package.json"));
var { build } = require3("vite");
var reactPlugin2 = require3("@vitejs/plugin-react").default;
var tailwindcss2 = require3("@tailwindcss/vite").default;
async function buildCssBundle(options) {
  const { componentPath, slug, config } = options;
  const outputDir = path5.join(process.cwd(), config.outDir);
  const tempDir = path5.join(process.cwd(), "node_modules", ".vite-plugin-ssg");
  fs4.mkdirSync(tempDir, { recursive: true });
  const tempEntryPath = path5.join(tempDir, `_temp_${slug}_entry.tsx`);
  const relativePath = path5.relative(path5.dirname(tempEntryPath), componentPath);
  const globalCssAbsolute = path5.join(process.cwd(), config.css.globalCssPath);
  const globalCssRelative = path5.relative(path5.dirname(tempEntryPath), globalCssAbsolute);
  const tempEntryContent = `
        import '${globalCssRelative}';
        import '${relativePath}';
    `;
  fs4.writeFileSync(tempEntryPath, tempEntryContent);
  try {
    const plugins = [
      reactPlugin2(),
      tailwindcss2(),
      ...config.vite.plugins
    ];
    await build({
      configFile: false,
      // Don't load vite.config.ts
      root: process.cwd(),
      // Use project's root to resolve node_modules
      plugins,
      build: {
        outDir: outputDir,
        emptyOutDir: false,
        rollupOptions: {
          input: tempEntryPath,
          output: {
            entryFileNames: `${slug}.js`,
            chunkFileNames: `${slug}-[hash].js`,
            assetFileNames: `${slug}.[ext]`
          },
          external: ["sharp", "fsevents"]
        },
        cssCodeSplit: false,
        cssMinify: config.css.minify,
        minify: true
      },
      logLevel: toViteLogLevel(config.logLevel)
    });
    const files = fs4.readdirSync(outputDir);
    for (const file of files) {
      if (file.endsWith(".js") && !file.includes("hydrate")) {
        fs4.unlinkSync(path5.join(outputDir, file));
      }
    }
    const cssFileName = `${slug}.css`;
    const cssExists = fs4.existsSync(path5.join(outputDir, cssFileName));
    return {
      cssPath: cssExists ? `${config.baseUrl}/${cssFileName}` : null
    };
  } finally {
    if (fs4.existsSync(tempEntryPath)) {
      fs4.unlinkSync(tempEntryPath);
    }
  }
}

// src/hydration-builder.ts
import path6 from "path";
import fs5 from "fs";
import { createRequire as createRequire3 } from "module";
var require4 = createRequire3(path6.join(process.cwd(), "package.json"));
var { build: build2 } = require4("vite");
var reactPlugin3 = require4("@vitejs/plugin-react").default;
var tailwindcss3 = require4("@tailwindcss/vite").default;
async function buildHydrationBundle(options) {
  const { slug, islands, config } = options;
  const outputDir = path6.join(process.cwd(), config.outDir);
  if (islands.length === 0) {
    return { hydratePath: null };
  }
  const hydrateScript = generateHydrationScript(islands);
  const tempDir = path6.join(process.cwd(), "node_modules", ".vite-plugin-ssg");
  fs5.mkdirSync(tempDir, { recursive: true });
  const hydrateEntryPath = path6.join(tempDir, `_temp_${slug}_hydrate.tsx`);
  fs5.writeFileSync(hydrateEntryPath, hydrateScript);
  try {
    const plugins = [
      reactPlugin3(),
      tailwindcss3(),
      ...config.vite.plugins
    ];
    const terserOptions = config.js.minify === "terser" ? {
      compress: {
        drop_console: config.js.terserOptions.dropConsole,
        drop_debugger: config.js.terserOptions.dropDebugger,
        passes: config.js.terserOptions.passes
      },
      mangle: true,
      format: {
        comments: false
      }
    } : void 0;
    await build2({
      configFile: false,
      // Don't load vite.config.ts
      root: process.cwd(),
      // Use project's root to resolve node_modules
      plugins,
      build: {
        outDir: outputDir,
        emptyOutDir: false,
        rollupOptions: {
          input: hydrateEntryPath,
          output: {
            entryFileNames: `${slug}-hydrate.js`,
            chunkFileNames: `${slug}-hydrate-[hash].js`,
            assetFileNames: `${slug}-hydrate.[ext]`
          },
          external: ["sharp", "fsevents"],
          treeshake: {
            moduleSideEffects: false
          }
        },
        minify: config.js.minify,
        terserOptions,
        target: config.js.target
      },
      logLevel: toViteLogLevel(config.logLevel)
    });
    return {
      hydratePath: `${config.baseUrl}/${slug}-hydrate.js`
    };
  } finally {
    if (fs5.existsSync(hydrateEntryPath)) {
      fs5.unlinkSync(hydrateEntryPath);
    }
  }
}

// src/html-template.ts
function generateHtmlTemplate(options) {
  const {
    headContent,
    bodyContent,
    cssPath,
    hydrateJsPath,
    routeUrl,
    imagePreloadTags = "",
    config
  } = options;
  return `<!DOCTYPE html>
<html lang="${config.html.lang}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Preload critical images (LCP) -->
    ${imagePreloadTags}

    <!-- CSS (render-blocking to prevent layout shift) -->
    ${cssPath ? `<link rel="stylesheet" href="${cssPath}">` : ""}

    <!-- Page-defined head content -->
    ${headContent}

    <!-- Additional head tags from config -->
    ${config.html.headTags}
</head>
<body>
    <div id="root">${bodyContent}</div>
    ${hydrateJsPath ? generateHydrationScript2(hydrateJsPath, routeUrl) : ""}
    ${config.html.bodyTags}
</body>
</html>`;
}
function generateHydrationScript2(hydrateJsPath, routeUrl) {
  return `<!-- SSR route for hydration consistency -->
    <script>window.__SSR_ROUTE__ = ${JSON.stringify(routeUrl)};</script>
    <!-- Lazy-load hydration script when user interacts or island is visible -->
    <script>
    (function() {
      var loaded = false;
      function loadHydration() {
        if (loaded) return;
        loaded = true;
        var s = document.createElement('script');
        s.type = 'module';
        s.src = ${JSON.stringify(hydrateJsPath)};
        document.body.appendChild(s);
      }
      // Load on any user interaction
      ['click', 'touchstart', 'mouseover', 'scroll'].forEach(function(e) {
        document.addEventListener(e, loadHydration, { once: true, passive: true });
      });
      // Also load when islands become visible (IntersectionObserver)
      if ('IntersectionObserver' in window) {
        var observer = new IntersectionObserver(function(entries) {
          entries.forEach(function(entry) {
            if (entry.isIntersecting) { loadHydration(); observer.disconnect(); }
          });
        }, { rootMargin: '200px' });
        document.querySelectorAll('[data-island]').forEach(function(el) { observer.observe(el); });
      } else {
        // Fallback: load after idle
        if ('requestIdleCallback' in window) { requestIdleCallback(loadHydration); }
        else { setTimeout(loadHydration, 2000); }
      }
    })();
    </script>`;
}

// src/gen-static.ts
async function generateStaticPage(pageConfig, ssgConfig) {
  const { componentPath, slug, routeUrl, hasHead } = pageConfig;
  const srcDir = path7.join(process.cwd(), ssgConfig.srcDir);
  const outputDir = path7.join(process.cwd(), ssgConfig.outDir);
  fs6.mkdirSync(outputDir, { recursive: true });
  console.log(`[${slug}] Scanning for islands...`);
  const islands = scanForIslands(componentPath, srcDir);
  if (islands.length > 0) {
    console.log(`[${slug}] Found ${islands.length} island(s): ${islands.map((i) => i.name).join(", ")}`);
  } else {
    console.log(`[${slug}] No islands found`);
  }
  console.log(`[${slug}] Rendering HTML...`);
  const { bodyHtml, headHtml } = await renderPage({
    componentPath,
    routeUrl,
    islands,
    renderHead: hasHead,
    config: ssgConfig
  });
  let optimizedBodyHtml = bodyHtml;
  let imagePreloadTags = "";
  if (ssgConfig.images.enabled) {
    console.log(`[${slug}] Optimizing images...`);
    const { html, images: optimizedImages } = await optimizeImages(
      bodyHtml,
      {
        outputDir,
        baseUrl: ssgConfig.baseUrl,
        formats: ssgConfig.images.formats,
        quality: ssgConfig.images.quality,
        generateSrcset: ssgConfig.images.generateSrcset,
        srcsetMultipliers: ssgConfig.images.srcsetMultipliers
      }
    );
    optimizedBodyHtml = html;
    imagePreloadTags = generateImagePreloads(optimizedImages, ssgConfig.images.lcpImageCount);
  }
  console.log(`[${slug}] Building CSS bundle...`);
  const { cssPath } = await buildCssBundle({
    componentPath,
    slug,
    config: ssgConfig
  });
  console.log(`[${slug}] CSS bundle created`);
  let hydratePath = null;
  if (islands.length > 0) {
    console.log(`[${slug}] Building hydration bundle...`);
    const result = await buildHydrationBundle({
      slug,
      islands,
      config: ssgConfig
    });
    hydratePath = result.hydratePath;
    console.log(`[${slug}] Hydration bundle created`);
  }
  const finalHtml = generateHtmlTemplate({
    headContent: headHtml,
    bodyContent: optimizedBodyHtml,
    cssPath,
    hydrateJsPath: hydratePath,
    routeUrl,
    imagePreloadTags,
    config: ssgConfig
  });
  const outputPath = path7.join(outputDir, `${slug}.html`);
  fs6.writeFileSync(outputPath, finalHtml);
  console.log(`[${slug}] Static page generated: ${ssgConfig.outDir}/${slug}.html`);
}
async function generateStatic(input, userConfig = {}) {
  await generateStaticWithInfo(input, userConfig);
}
async function generateStaticWithInfo(input, userConfig = {}) {
  const config = resolveConfig(userConfig);
  const pages = await discoverPages(input, config);
  if (pages.length === 0) {
    throw new Error("No pages found to generate");
  }
  console.log(`[SSG] Generating ${pages.length} static page(s)...`);
  const generatedPages = [];
  for (const pageConfig of pages) {
    await generateStaticPage(pageConfig, config);
    generatedPages.push({
      slug: pageConfig.slug,
      routeUrl: pageConfig.routeUrl,
      htmlPath: `${pageConfig.slug}.html`
    });
  }
  console.log("[SSG] Done!");
  return { pages: generatedPages };
}

// src/plugin/generator.ts
async function generateStaticPages(options, _viteConfig) {
  const ssgConfig = {
    ...options.config,
    // Set log level based on verbose flag
    logLevel: options.verbose ? "debug" : options.config.logLevel ?? "info"
  };
  const allPages = [];
  for (const pagePath of options.pages) {
    if (options.verbose) {
      console.log(`[vite-plugin-ssg] Processing: ${pagePath}`);
    }
    const result = await generateStaticWithInfo(pagePath, ssgConfig);
    allPages.push(...result.pages);
  }
  return { pages: allPages };
}

// src/plugin/hosting/firebase.ts
import fs7 from "fs";
import path8 from "path";
function isSsgRewrite(rewrite, baseUrl) {
  return !!(rewrite.destination && rewrite.destination.startsWith(baseUrl + "/") && rewrite.destination.endsWith(".html"));
}
function createFirebaseConfigurator(firebaseJsonPath) {
  const absolutePath = path8.isAbsolute(firebaseJsonPath) ? firebaseJsonPath : path8.join(process.cwd(), firebaseJsonPath);
  return {
    name: "firebase",
    async configure(pages, baseUrl) {
      if (!fs7.existsSync(absolutePath)) {
        throw new Error(`Firebase config not found: ${absolutePath}`);
      }
      const content = fs7.readFileSync(absolutePath, "utf-8");
      const config = JSON.parse(content);
      let hostingConfig;
      if (Array.isArray(config.hosting)) {
        hostingConfig = config.hosting[0];
      } else if (config.hosting) {
        hostingConfig = config.hosting;
      } else {
        throw new Error("No hosting configuration found in firebase.json");
      }
      if (!hostingConfig.rewrites) {
        hostingConfig.rewrites = [];
      }
      const existingRewrites = hostingConfig.rewrites.filter(
        (r) => !isSsgRewrite(r, baseUrl)
      );
      const ssgRewrites = pages.map((page) => ({
        source: page.routeUrl === "/" ? "/" : page.routeUrl,
        destination: `${baseUrl}/${page.slug}.html`
      }));
      const catchAllIndex = existingRewrites.findIndex(
        (r) => r.source === "**" || r.source === "/**"
      );
      let newRewrites;
      if (catchAllIndex >= 0) {
        newRewrites = [
          ...existingRewrites.slice(0, catchAllIndex),
          ...ssgRewrites,
          ...existingRewrites.slice(catchAllIndex)
        ];
      } else {
        newRewrites = [...ssgRewrites, ...existingRewrites];
      }
      hostingConfig.rewrites = newRewrites;
      const output = JSON.stringify(config, null, 2);
      fs7.writeFileSync(absolutePath, output + "\n");
      console.log(
        `[SSG] Updated firebase.json with ${ssgRewrites.length} rewrite(s)`
      );
    }
  };
}

// src/plugin/dev-middleware.ts
import path9 from "path";
import fs8 from "fs";
function extractSsgOptionsFromFile2(filePath) {
  try {
    const content = fs8.readFileSync(filePath, "utf-8");
    const ssgOptionsMatch = content.match(
      /export\s+const\s+ssgOptions\s*[=:][^{]*\{([^}]+)\}/s
    );
    if (!ssgOptionsMatch) {
      return null;
    }
    const optionsContent = ssgOptionsMatch[1];
    const slugMatch = optionsContent.match(/slug\s*:\s*["'`]([^"'`]+)["'`]/);
    if (!slugMatch) {
      return null;
    }
    const slug = slugMatch[1];
    const routeUrlMatch = optionsContent.match(/routeUrl\s*:\s*["'`]([^"'`]+)["'`]/);
    const routeUrl = routeUrlMatch ? routeUrlMatch[1] : "/";
    return {
      slug,
      routeUrl,
      htmlPath: `${slug}.html`
    };
  } catch {
    return null;
  }
}
function discoverStaticRoutes(options) {
  const routes = [];
  for (const pagePath of options.pages) {
    const absolutePath = path9.isAbsolute(pagePath) ? pagePath : path9.join(process.cwd(), pagePath);
    if (!fs8.existsSync(absolutePath)) {
      continue;
    }
    const stats = fs8.statSync(absolutePath);
    if (stats.isFile()) {
      const route = extractSsgOptionsFromFile2(absolutePath);
      if (route) {
        routes.push(route);
      }
    } else if (stats.isDirectory()) {
      const files = fs8.readdirSync(absolutePath).filter((f) => f.endsWith(".tsx") || f.endsWith(".jsx")).map((f) => path9.join(absolutePath, f));
      for (const filePath of files) {
        const route = extractSsgOptionsFromFile2(filePath);
        if (route) {
          routes.push(route);
        }
      }
    }
  }
  return routes;
}
function generateNotGeneratedHtml(route) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Page Not Generated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 48px;
            backdrop-filter: blur(10px);
        }
        .icon {
            font-size: 64px;
            margin-bottom: 24px;
        }
        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #fff;
        }
        p {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 24px;
            color: #b0b0b0;
        }
        .route-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin: 24px 0;
            text-align: left;
        }
        .route-info code {
            display: block;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 14px;
            color: #7dd3fc;
            margin: 8px 0;
        }
        .label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .command {
            background: #0f172a;
            border-radius: 8px;
            padding: 16px;
            margin-top: 24px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 14px;
            color: #4ade80;
            text-align: left;
        }
        .command::before {
            content: '$ ';
            color: #888;
        }
        .tip {
            font-size: 14px;
            color: #888;
            margin-top: 24px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">\u{1F3D7}\uFE0F</div>
        <h1>Static Page Not Yet Generated</h1>
        <p>
            This route is configured for static site generation,
            but the HTML file hasn't been built yet.
        </p>

        <div class="route-info">
            <div class="label">Route URL</div>
            <code>${route.routeUrl}</code>
            <div class="label" style="margin-top: 12px;">Expected File</div>
            <code>${route.htmlPath}</code>
        </div>

        <p>Run a production build to generate static pages:</p>

        <div class="command">npm run build</div>

        <p class="tip">
            \u{1F4A1} Tip: Static pages are only generated during production builds.
            In development, you're seeing this page because the SSG middleware
            detected this route should have a pre-rendered version.
        </p>
    </div>
</body>
</html>`;
}
function getContentType(filePath) {
  const ext = path9.extname(filePath).toLowerCase();
  const contentTypes = {
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".mjs": "application/javascript",
    ".json": "application/json",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".svg": "image/svg+xml",
    ".webp": "image/webp",
    ".ico": "image/x-icon",
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".ttf": "font/ttf",
    ".eot": "application/vnd.ms-fontobject"
  };
  return contentTypes[ext] || "application/octet-stream";
}
function createDevMiddleware(options) {
  return (server) => {
    let cachedRoutes = null;
    const getRoutes = () => {
      if (!cachedRoutes) {
        cachedRoutes = discoverStaticRoutes(options);
        if (options.verbose && cachedRoutes.length > 0) {
          console.log(
            `[SSG Dev] Discovered ${cachedRoutes.length} route(s): ${cachedRoutes.map((r) => r.routeUrl).join(", ")}`
          );
        }
      }
      return cachedRoutes;
    };
    server.watcher.on("change", (filePath) => {
      if (filePath.endsWith(".tsx") || filePath.endsWith(".jsx")) {
        cachedRoutes = null;
      }
    });
    const baseUrl = options.config.baseUrl || "/static";
    const outDir = options.config.outDir || "dist/static";
    const middleware = (req, res, next) => {
      const url = req.url?.split("?")[0] || "/";
      if (url.startsWith("/@") || url.startsWith("/__")) {
        return next();
      }
      if (url.startsWith(baseUrl + "/")) {
        const relativePath = url.slice(baseUrl.length + 1);
        const filePath = path9.join(process.cwd(), outDir, relativePath);
        if (fs8.existsSync(filePath) && fs8.statSync(filePath).isFile()) {
          const contentType = getContentType(filePath);
          const content = fs8.readFileSync(filePath);
          res.setHeader("Content-Type", contentType);
          res.setHeader("X-SSG-Dev-Middleware", "asset");
          res.setHeader("Cache-Control", "no-cache");
          res.end(content);
          return;
        }
      }
      if (url.match(/\.(js|ts|tsx|jsx|css|scss|png|jpg|jpeg|gif|svg|webp|ico|woff|woff2|ttf|eot)$/)) {
        return next();
      }
      try {
        const routes = getRoutes();
        const matchingRoute = routes.find((r) => {
          if (r.routeUrl === url) return true;
          if (r.routeUrl === "/" && url === "/") return true;
          if (url === r.routeUrl + "/" || url + "/" === r.routeUrl) return true;
          return false;
        });
        if (!matchingRoute) {
          return next();
        }
        const staticFilePath = path9.join(
          process.cwd(),
          outDir,
          matchingRoute.htmlPath
        );
        if (fs8.existsSync(staticFilePath)) {
          if (options.verbose) {
            console.log(`[SSG Dev] Serving static: ${matchingRoute.htmlPath}`);
          }
          const content = fs8.readFileSync(staticFilePath, "utf-8");
          res.setHeader("Content-Type", "text/html");
          res.setHeader("X-SSG-Dev-Middleware", "static");
          res.end(content);
          return;
        }
        if (options.verbose) {
          console.log(`[SSG Dev] Static not found: ${matchingRoute.htmlPath}`);
        }
        const html = generateNotGeneratedHtml(matchingRoute);
        res.setHeader("Content-Type", "text/html");
        res.setHeader("X-SSG-Dev-Middleware", "not-generated");
        res.statusCode = 200;
        res.end(html);
      } catch (error) {
        console.error("[SSG Dev] Middleware error:", error);
        next();
      }
    };
    server.middlewares.use(middleware);
    if (options.verbose) {
      console.log("[SSG Dev] Middleware installed - simulating hosting rewrites");
      console.log(`[SSG Dev] Serving static assets from ${baseUrl}/ -> ${outDir}/`);
    }
  };
}

// src/plugin/index.ts
var PLUGIN_NAME = "vite-plugin-ssg";
function resolvePluginOptions(options) {
  const pages = Array.isArray(options.pages) ? options.pages : [options.pages];
  return {
    pages,
    config: options.config ?? {},
    hosting: options.hosting,
    runInDev: options.runInDev ?? false,
    devMiddleware: options.devMiddleware ?? true,
    // Enabled by default
    verbose: options.verbose ?? false
  };
}
function ssgPlugin(options) {
  const resolvedOptions = resolvePluginOptions(options);
  let viteConfig;
  let isBuild = false;
  let hasRun = false;
  return {
    name: PLUGIN_NAME,
    // Run after other build plugins
    enforce: "post",
    // Always apply - middleware runs in dev, SSG runs in build
    apply() {
      return true;
    },
    /**
     * Store the resolved Vite config for later use
     */
    configResolved(config) {
      viteConfig = config;
      isBuild = config.command === "build";
      if (resolvedOptions.verbose) {
        console.log(`[${PLUGIN_NAME}] Config resolved, command: ${config.command}`);
      }
    },
    /**
     * Configure dev server middleware to simulate hosting rewrites.
     * This allows testing static page routing during development.
     */
    configureServer: resolvedOptions.devMiddleware ? createDevMiddleware(resolvedOptions) : void 0,
    /**
     * Generate static pages after the bundle is written to disk.
     * We use writeBundle because:
     * 1. All assets are already written to disk
     * 2. We can run our own Vite SSR server without conflicts
     */
    async writeBundle() {
      if (!isBuild || hasRun) {
        return;
      }
      hasRun = true;
      console.log(`[${PLUGIN_NAME}] Generating static pages...`);
      const startTime = Date.now();
      try {
        const result = await generateStaticPages(resolvedOptions, viteConfig);
        if (resolvedOptions.hosting?.firebaseJson) {
          const configurator = createFirebaseConfigurator(
            resolvedOptions.hosting.firebaseJson
          );
          const baseUrl = resolvedOptions.config.baseUrl ?? "/static";
          await configurator.configure(result.pages, baseUrl);
        }
        const duration = ((Date.now() - startTime) / 1e3).toFixed(2);
        console.log(`[${PLUGIN_NAME}] Static pages generated in ${duration}s`);
      } catch (error) {
        console.error(`[${PLUGIN_NAME}] Error generating static pages:`, error);
        throw error;
      }
    }
  };
}
export {
  DEFAULT_CONFIG,
  generateStatic,
  resolveConfig,
  ssgPlugin
};
